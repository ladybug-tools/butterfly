
# Anton Szilasi 11/10/2015
# This code is the first step in automating the creation of a blockMeshDict for Open Foam using Theodores example

"""
    Args:
        Brep: ...
        avg:
        Min_X:
        Max_X:
        Min_Y:
        Max_Y:
        Max_Z:
        blockMeshCells: A vector of each blockMeshcell
            
    Returns:
        BlockMeshDict: The BlockMeshDict file.

"""


import Rhino


# Create the standard blockMeshDict header

header = '/*--------------------------------*- C++ -*----------------------------------*\\n'+\
'| =========                 |                                                 |\n'+\
'| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n'+\
'|  \\    /   O peration     | Version:  2.4.0                                 |\n'+\
'|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |\n'+\
'|    \\/     M anipulation  |                                                 |\n'+\
'\*---------------------------------------------------------------------------*/\n'+\
'FoamFile\n'+\
'\t'+'{\n'+\
'\t'+'version         2.0;\n'+\
'\t'+'format          ascii;\n'+\
'\t'+'class           dictionary;\n'+\
'\t'+'object          blockMeshDict;\n'+\
'\t'+'}\n'+\
'// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n'+\
'\n'+\
'\t'+'convertToMeters 1;\n'+\
'\n'+\
'\t'+'vertices\n'+\
'\t'+'('+\
'\t'+'\n'

# 1. Get Vertices of the Brep 

sumBrepVertices = []

for verticeNum,vertice in enumerate(Brep.Vertices):
    
    sumBrepVertices.append(vertice.Location[0]+vertice.Location[1]+vertice.Location[2])

# TO DO Check what if two vertices are the same value?
# Get the extreme vertices of the input brep

maxVertex = Brep.Vertices[[i for i, j in enumerate(sumBrepVertices) if j == max(sumBrepVertices)][0]]
minVertex = Brep.Vertices[[i for i, j in enumerate(sumBrepVertices) if j == min(sumBrepVertices)][0]]


# 2. Set Domain around by creating a box from these two points

# Point one
minX = minVertex.Location[0]+(avg*Min_X)
minY = minVertex.Location[1]*Min_Y+minVertex.Location[0]
minZ = minVertex.Location[2]

# Point two
maxX = maxVertex.Location[0] + avg*Max_X
maxY = maxVertex.Location[1]*Max_Y+minVertex.Location[0]
maxZ = maxVertex.Location[2]*Max_Z

PointMax = Rhino.Geometry.Point3d(maxX,maxY,maxZ)
PointMin = Rhino.Geometry.Point3d(minX,minY,minZ)

# Create the domain box from these two points 

DomainBox = Rhino.Geometry.Box(Rhino.Geometry.Plane.WorldXY,[PointMin,PointMax])

# TO DO Tried converting Box to a brep HERE - for some reason this is not working, ask GH community

domainBoxVertices = DomainBox.GetCorners() 

# Get the vertices of the box

sumDomainBoxVertices = []

for pointNum,point in enumerate(domainBoxVertices):
    
    sumDomainBoxVertices.append(point[0]+point[1]+point[2])
    
# TO DO Check what if two vertices are the same value?
# Get the extreme vertices of the box 

# number two output maxVertex and minVertex

maxVertex = domainBoxVertices[[i for i, j in enumerate(sumDomainBoxVertices) if j == max(sumDomainBoxVertices)][0]]
minVertex = domainBoxVertices[[i for i, j in enumerate(sumDomainBoxVertices) if j == min(sumDomainBoxVertices)][0]]

# 3. Refinement of block mesh

# X domain

Xvertices = []

for point in DomainBox.GetCorners(): 

    Xvertices.append(point[0])
    
Xdomain = abs(min(Xvertices))+abs(max(Xvertices))

# Y domain

Yvertices = []

for point in DomainBox.GetCorners(): 

    Yvertices.append(point[1])
    
Ydomain = abs(min(Yvertices))+abs(max(Yvertices))

# Z domain

Zvertices = []

for point in DomainBox.GetCorners(): 

    Zvertices.append(point[2])
    
# Construct domain Z
    
ZdomainEnd = abs(min(Zvertices))+abs(max(Zvertices))

# All domains are min and then max

# Construct domain X and Y

XYdomain = Xdomain,Ydomain

XYdomainStart = min(Xdomain,Ydomain)

XYdomainEnd = max(Xdomain,Ydomain)


Xcellsize = int(round(XYdomainStart/blockMeshCells.X,0))

Ycellsize = int(round(XYdomainEnd/blockMeshCells.Y,0))

Zcellsize = int(round(ZdomainEnd/blockMeshCells.Z,0))


def returnVertices(DomainBox):
    
    Vertices = ''
    
    for point in DomainBox.GetCorners():
        
            Vertices += '('+str(point).replace(",", " ")+') \n'
        
    Vertices += ');'
        
    return Vertices


blocks = '\t'+'\n'+\
'\t'+'blocks\n'+\
'\t'+'(\n'+\
'\t'+'hex (0 1 2 3 4 5 6 7) ('

remainder = u"""simpleGrading (1 1 1)
);

edges
(
);

boundary
(
    outlet
    {
        type patch;
        faces
        (
            (2 6 5 1)
        );
    }
    sides
    {
        type patch;
        faces
        (
            (1 5 4 0)
            (3 7 6 2)
        );
    }
    inlet
    {
        type patch;
        faces
        (
            (0 4 7 3)
        );
    }
    ground
    {
        type wall;
        faces
        (
            (0 3 2 1)
        );
    }
    top
    {
        type patch;
        faces
        (
            (4 5 6 7)
        );
    }
);

mergePatchPairs
(
);


// ************************************************************************* //'

"""
# Trying to convert the string above into code - Is there a way to automatically convert it???

BlockmeshDict = header+returnVertices(DomainBox)+blocks+remainder

"""
remainder = '\t'+'simpleGrading (1 1 1)\n'+\
'\t'+');\n'+\
'\n'+\
'\t'+'edges\n'+\
'\t'+'(\n'+\
'\t'+');\n'+\
'\n'+\
'\t'+'boundary\n'+\
'\t'+'(\n'+\
'\t'+'outlet\n'+\
'\t'+'{\n'+\
'\t'+'type patch;\n'+\
'\t'+'faces\n'+\
'\t'+'(\n'+\
'\t'+'(2 6 5 1)\n'+\
'\t'+');\n'+\
'\t'+'}\n'+\
'\t'+'sides\n'+\
'\t'+'{\n'+\
'\t'+'type patch;\n'+\
'\t'+'faces\n'+\
'\t'+'(\n'+\
'\t'+'(1 5 4 0)\n'+\
'\t'+'(3 7 6 2)\n'+\
'\t'+');\n'+\
'\t'+'}\n'+\
'\t'+'inlet\n'+\
'\t'+'{\n'+\
'\t'+'type patch;\n'+\
'\t'+'faces\n'+\
'\t'+'(\n'+\
'\t'+'(0 4 7 3)\n'+\
'\t'+');\n'+\
'\t'+'}\n'+\
'\t'+'ground\n'+\
'\t'+'{\n'+\
'\t'+'type wall;\n'+\
'\t'+'faces\n'+\
'\t'+'(\n'+\
'\t'+'(0 3 2 1)\n'+\
'\t'+');\n'+\
'\t'+'}\n'+\
'\t'+'top\n'+\
'\t'+'{\n'+\
'\t'+'type patch;\n'+\
'\t'+'faces\n'+\
'\t'+'(\n'+\
'\t'+'(4 5 6 7)\n'+\
'\t'+');\n'+\
'\t'+'}\n'+\
'\t'+');\n'+\
"""