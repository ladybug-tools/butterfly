<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>butterfly.blockMeshDict API documentation</title>
    <meta name="description" content="BlockMeshDict class." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

  <!-- highlight.js for highlighting source code. -->
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>

  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 0.9em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    margin-left: 25%;
    max-width: 90%;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    position: fixed;
    height: 100%;
    width: 25%;
    float: left;
    padding: 30px;
    overflow-x: hidden;
    overflow-y: auto;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }

  .desc {
    white-space: pre-wrap;
  }

  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
        position: inherit;
        float: none;
        width: auto;
    }
    #content {
      width: 95%;
      margin-left: auto;
      border-left: none;
      padding: 30px;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#butterfly.blockMeshDict.BlockMeshDict">BlockMeshDict</a></span>
        
          
  <ul>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.convertBoolValue">convertBoolValue</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.__init__">__init__</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.ToString">ToString</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.body">body</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.duplicate">duplicate</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries">fromBFBlockGeometries</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromFile">fromFile</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromMinMax">fromMinMax</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize">fromOriginAndSize</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromVertices">fromVertices</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.getValueByParameter">getValueByParameter</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.header">header</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.make2d">make2d</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize">nDivXYZByCellSize</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.save">save</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.setValueByParameter">setValueByParameter</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM">toOpenFOAM</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters">updateMeshingParameters</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.updateValues">updateValues</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">butterfly.blockMeshDict</span> module</h1>
  <p>BlockMeshDict class.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict" class="source">
    <pre><code># coding=utf-8
"""BlockMeshDict class."""
from .boundarycondition import BoundingBoxBoundaryCondition
from .foamfile import FoamFile
from .fields import Empty
import vectormath
from .grading import SimpleGrading, Grading, MultiGrading
from .parser import CppDictParser
from .geometry import BFGeometry
from math import sqrt, sin, cos, radians
from collections import OrderedDict


class BlockMeshDict(FoamFile):
    """BlockMeshDict."""

    __defaultValues = OrderedDict()
    __defaultValues['convertToMeters'] = 1
    __defaultValues['vertices'] = None
    __defaultValues['blocks'] = None
    __defaultValues['boundary'] = {}

    def __init__(self, values=None):
        """Init class."""
        FoamFile.__init__(self, name='blockMeshDict', cls='dictionary',
                          location='system', defaultValues=self.__defaultValues,
                          values=values)

        self.__BFBlockGeometries = None # this will be overwritten in classmethods
        self.__vertices = None

    @classmethod
    def fromFile(cls, filepah):
        """Create a blockMeshDict from file."""
        _cls = cls()

        with open(filepah, 'rb') as bf:
            lines = CppDictParser._removeComments(bf.read())
            bmd = ' '.join(lines.replace('\r\n', ' ').replace('\n', ' ').split())

        _cls.values['convertToMeters'] = \
            float(bmd.split('convertToMeters')[-1].split(';')[0])

        # find vertices
        _cls.__vertices = eval(','.join(bmd.split('vertices')[-1]
                                        .split(';')[0]
                                        .strip()[1:-1]
                                        .split()))

        # get blocks, order of vertices, nDivXYZ, grading
        blocks = bmd.split('blocks')[-1].split(';')[0].strip()
        xyz, simpleGrading = blocks.split('simpleGrading')

        _cls.__order, _cls.nDivXYZ = eval(','.join(xyz.split('hex')[-1].split()))

        simpleGrading = eval(','.join(simpleGrading.strip()[:-1]
                                      .replace('( ', '(')
                                      .replace(' )', ')')
                                      .split()))

        _cls.grading = SimpleGrading(
            *(MultiGrading(tuple(Grading(*i) for i in g))
              if isinstance(g, tuple) else Grading(g)
              for g in simpleGrading))

        # recreate boundary faces
        boundaryString = bmd.replace(' (', '(').replace(' )', ')') \
            .split('boundary(')[-1].strip().replace('});', '}') \
            .replace('));', ');').replace('((', ' (').replace(')(', ') (')

        _cls.values['boundary'] = {}
        for key, values in CppDictParser(boundaryString).values.iteritems():
            if isinstance(values, dict) and 'type' in values and 'faces' in values:
                values['faces'] = eval(str(values['faces']).replace(' ', ','))

                _cls.values['boundary'][key] = values

        del((lines, bmd))
        return _cls

    @classmethod
    def fromOriginAndSize(cls, origin, width, length, height, convertToMeters=1,
                          nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            origin: Minimum point of bounding box as (x, y, z).
            width: Width in x direction.
            length: Length in y direction.
            height: Height in y direction.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        vertices = tuple(
            vectormath.move(origin,
                            vectormath.sums((vectormath.scale(_xAxis, i *  width),
                                            vectormath.scale(_yAxis, j *  length),
                                            vectormath.scale(_zAxis, k *  height))
                            ))
            for i in range(2) for j in range(2) for k in range(2))

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromMinMax(cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None,
                   xAxis=None):
        """Create BlockMeshDict from minimum and maximum point.

        Args:
            minPt: Minimum point of bounding box as (x, y, z).
            maxPt: Maximum point of bounding box as (x, y, z).
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        diagonal2D = tuple(i - j for i, j in zip(maxPt, minPt))[:2]
        _angle = radians(vectormath.angleAnitclockwise(_xAxis[:2], diagonal2D))
        width = cos(_angle) * vectormath.length(diagonal2D)
        length = sin(_angle) * vectormath.length(diagonal2D)
        height = maxPt[2] - minPt[2]

        vertices = tuple(
            vectormath.move(minPt,
                            vectormath.sums((vectormath.scale(_xAxis, i *  width),
                                            vectormath.scale(_yAxis, j *  length),
                                            vectormath.scale(_zAxis, k *  height))
                            ))
            for i in range(2) for j in range(2) for k in range(2))

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromVertices(cls, vertices, convertToMeters=1, nDivXYZ=None,
                     grading=None, xAxis=None):
        """Create BlockMeshDict from vertices.

        Args:
            vertices: 8 vertices to define the bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__rawvertices = vertices

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
        _cls.__vertices = _cls.__sortVertices()

        # update self.values['boundary']
        _cls.__updateBoundaryFromSortedVertices()

        _cls.__order = tuple(range(8))

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading

        return _cls

    @classmethod
    def fromBFBlockGeometries(cls, BFBlockGeometries, convertToMeters=1,
                              nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            BFBlockGeometries: A collection of boundary surfaces for bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__BFBlockGeometries = BFBlockGeometries

        try:
            # collect uniqe vertices from all BFGeometries
            _cls.__rawvertices = tuple(
                set(v for f in _cls.__BFBlockGeometries
                    for vgroup in f.borderVertices
                    for v in vgroup))
        except AttributeError as e:
            raise TypeError('At least one of the input geometries is not a '
                            'Butterfly block geometry:\n\t{}'.format(e))

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
        _cls.__vertices = _cls.__sortVertices()

        # update self.values['boundary']
        _cls.__updateBoundaryFromBFBlockGeometries()

        _cls.__order = tuple(range(8))

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading

        return _cls

    @property
    def convertToMeters(self):
        """Get convertToMeters."""
        return self.values['convertToMeters']

    @property
    def boundary(self):
        """Get boundaries and a dictionary."""
        return self.values['boundary']

    @property
    def vertices(self):
        """Get the sorted list of vertices."""
        return self.__vertices

    @property
    def verticesOrder(self):
        """Get order of vertices in blocks."""
        return self.__order

    @property
    def geometry(self):
        """A tuple of BFGeometries for BoundingBox faces."""
        def __getBFGeometry(name, attr):
            bc = BoundingBoxBoundaryCondition()
            ind = attr['faces'] if hasattr(attr['faces'][0], '__iter__') else \
                (attr['faces'],)

            # unique indecies
            uniuqe = tuple(set(i for inx in ind for i in inx))

            renumberedIndx = tuple(tuple(uniuqe.index(i) for i in inx)
                                   for inx in ind)

            return BFGeometry(name, tuple(self.vertices[i] for i in uniuqe),
                              renumberedIndx, boundaryCondition=bc)

        if not self.__BFBlockGeometries:
            self.__BFBlockGeometries = tuple(
                __getBFGeometry(name, attr)
                for name, attr in self.boundary.iteritems())

        return self.__BFBlockGeometries

    @property
    def width(self):
        """Length of block in X direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[1]])

    @property
    def length(self):
        """Length of block in Y direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[3]])

    @property
    def height(self):
        """Length of block in Z direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[4]])

    @property
    def center(self):
        """Get center of the block."""
        return self.__averageVerices()

    @property
    def minZ(self):
        """Return minimum Z value of vertices in this block."""
        return self.vertices[self.verticesOrder[0]][2]

    @property
    def nDivXYZ(self):
        """Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5)."""
        return self.__nDivXYZ

    @nDivXYZ.setter
    def nDivXYZ(self, dXYZ):
        self.__nDivXYZ = tuple(int(v) for v in dXYZ) if dXYZ else (5, 5, 5)

    @property
    def grading(self):
        """A simpleGrading (default: simpleGrading(1, 1, 1))."""
        return self.__grading

    @grading.setter
    def grading(self, g):
        self.__grading = g if g else SimpleGrading()

        assert hasattr(self.grading, 'isSimpleGrading'), \
            'grading input ({}) is not a valid simpleGrading.'.format(g)

    def make2d(self, planeOrigin, planeNormal, width=0.1):
        """Create a new 2D blockMeshDict from this blockMeshDict.

        Args:
            planeOrigin: Plane origin as (x, y, z).
            planeNormal: Plane normal as (x, y, z).
            width: width of 2d blockMeshDict (default: 01).
        """
        # duplicate blockMeshDict
        bmd = self.duplicate()
        n = vectormath.normalize(planeNormal)

        # project all vertices to plane and move them in direction of normal
        # by half of width
        bmd.__vertices = tuple(
            self.__calculate2dPoints(v, planeOrigin, n, width)
            for v in bmd.vertices)

        # set boundary condition to empty
        # and number of divisions to 1 in shortest side
        minimum = min(bmd.width, bmd.length, bmd.height)
        if bmd.width == minimum:
            bmd.nDivXYZ = (1, bmd.nDivXYZ[1], bmd.nDivXYZ[2])
            # set both sides to empty

        elif bmd.length == minimum:
            bmd.nDivXYZ = (bmd.nDivXYZ[0], 1, bmd.nDivXYZ[2])
            # set inlet and outlet to empty
            # bmd.inlet.boundaryCondition = Empty()

        elif bmd.height == minimum:
            bmd.nDivXYZ = (bmd.nDivXYZ[0], bmd.nDivXYZ[1], 1)
            # set top and bottom to empty

        print('WARNING: make2d doesn\'t update boundary conditions to Empty.')
        return bmd

    @staticmethod
    def __calculate2dPoints(v, o, n, w):
        # project point
        p = vectormath.project(v, o, n)
        # move the projected point backwards for half of the width
        t = vectormath.scale(vectormath.normalize(vectormath.subtract(v, p)),
                             w / 2.0)
        return vectormath.move(p, t)

    def nDivXYZByCellSize(self, cellSizeXYZ):
        """Set number of divisions by cell size."""
        x, y, z = cellSizeXYZ
        self.nDivXYZ = int(round(self.width / x)), int(round(self.length / y)), \
            int(round(self.height / z))

    def updateMeshingParameters(self, meshingParameters):
        """Update meshing parameters for blockMeshDict."""
        if not meshingParameters:
            return

        assert hasattr(meshingParameters, 'isMeshingParameters'), \
            'Expected MeshingParameters not {}'.format(type(meshingParameters))

        if meshingParameters.cellSizeXYZ:
            self.nDivXYZByCellSize(meshingParameters.cellSizeXYZ)

        if meshingParameters.grading:
            self.grading = meshingParameters.grading

    def __updateBoundaryFromSortedVertices(self):
        """Update boundary dictionary based on BFBlockGeometries input."""
        self.values['boundary']['boundingbox'] = {
            'type': 'wall',
            'faces': ((0, 3, 2, 1), (4, 5, 6, 7),
                      (0, 1, 5, 4), (1, 2, 6, 5),
                      (2, 3, 7, 6), (3, 0, 4, 7),
                      )
        }

    def __updateBoundaryFromBFBlockGeometries(self):
        """Update boundary dictionary based on BFBlockGeometries input."""
        for geo in self.__BFBlockGeometries:
            try:
                self.values['boundary'][geo.name] = {
                    'type': geo.boundaryCondition.type,
                    'faces': tuple(tuple(self.vertices.index(v) for v in verGroup)
                                   for verGroup in geo.borderVertices)
                }
            except AttributeError as e:
                raise TypeError('Wrong input geometry!\n{}'.format(e))

    def __boundaryToOpenFOAM(self):
        _body = "   %s\n" \
                "   {\n" \
                "       type %s;\n" \
                "       faces\n" \
                "       (" \
                "       %s\n" \
                "       );\n" \
                "   }\n"

        col = (_body % (name, attr['type'],
               '\n' + '\n'.join('\t' + str(indices).replace(",", "")
                                for indices in attr['faces']))
               if isinstance(attr['faces'][0], tuple) else
               _body % (name, attr['type'],
                        '\n\t' + str(attr['faces']).replace(",", ""))
               for name, attr in self.boundary.iteritems())

        return 'boundary\n(%s);\n' % '\n'.join(col)

    @staticmethod
    def __distance(v1, v2):
        return sqrt(sum((x - y) ** 2 for x, y in zip(v1, v2)))

    def __averageVerices(self):
        _x, _y, _z = 0, 0, 0

        for ver in self.__rawvertices:
            _x += ver[0]
            _y += ver[1]
            _z += ver[2]

        return _x * self.convertToMeters / len(self.__rawvertices), \
            _y * self.convertToMeters / len(self.__rawvertices), \
            _z * self.convertToMeters / len(self.__rawvertices)

    def __sortVertices(self):
        """sort input vertices."""
        groups = {}
        for p in self.__rawvertices:
            if p[2] not in groups:
                groups[p[2]] = []

            groups[p[2]].append((p[0], p[1]))

        zValues = groups.keys()
        zValues.sort()
        pointGroups = groups.values()

        assert len(zValues) == 2, \
            'Number of Z values must be 2 not {}: {}.'.format(len(zValues),
                                                              zValues)

        for g in pointGroups:
            assert len(g) == 4

        # the points in both height are identical so I just take the first group
        # and sort them
        xAxisReversed = (-self.xAxis[0], -self.xAxis[1])
        centerPt = self.center[:2]
        sortedPoints2d = \
            sorted(pointGroups[0],
                   key=lambda x: vectormath.angleAnitclockwise(
                       xAxisReversed, tuple(c1 - c2 for c1, c2
                                            in zip(x, centerPt))))

        sortedPoints = tuple((pt[0], pt[1], z) for z in zValues
                             for pt in sortedPoints2d)
        return sortedPoints

    def toOpenFOAM(self):
        """Return OpenFOAM representation as a string."""
        _hea = self.header()
        _body = "\nconvertToMeters %.4f;\n" \
                "\n" \
                "vertices\n" \
                "(\n\t%s\n);\n" \
                "\n" \
                "blocks\n" \
                "(\nhex %s %s %s\n);\n" \
                "\n" \
                "edges\n" \
                "(%s);\n" \
                "\n" \
                "%s" \
                "\n" \
                "mergePatchPair\n" \
                "(%s);\n"

        return _hea + \
            _body % (
                self.convertToMeters,
                "\n\t".join(tuple(str(ver).replace(",", "")
                                  for ver in self.vertices)),
                str(self.verticesOrder).replace(",", ""),
                str(self.nDivXYZ).replace(",", ""),
                self.grading,  # blocks
                "\n",  # edges
                self.__boundaryToOpenFOAM(),  # boundary
                "\n")  # merge patch pair

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """BlockMeshDict representation."""
        return self.toOpenFOAM()
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="butterfly.blockMeshDict.BlockMeshDict" class="name">class <span class="ident">BlockMeshDict</span></p>
      
  
    <div class="desc"><p>BlockMeshDict.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict" class="source">
    <pre><code>class BlockMeshDict(FoamFile):
    """BlockMeshDict."""

    __defaultValues = OrderedDict()
    __defaultValues['convertToMeters'] = 1
    __defaultValues['vertices'] = None
    __defaultValues['blocks'] = None
    __defaultValues['boundary'] = {}

    def __init__(self, values=None):
        """Init class."""
        FoamFile.__init__(self, name='blockMeshDict', cls='dictionary',
                          location='system', defaultValues=self.__defaultValues,
                          values=values)

        self.__BFBlockGeometries = None # this will be overwritten in classmethods
        self.__vertices = None

    @classmethod
    def fromFile(cls, filepah):
        """Create a blockMeshDict from file."""
        _cls = cls()

        with open(filepah, 'rb') as bf:
            lines = CppDictParser._removeComments(bf.read())
            bmd = ' '.join(lines.replace('\r\n', ' ').replace('\n', ' ').split())

        _cls.values['convertToMeters'] = \
            float(bmd.split('convertToMeters')[-1].split(';')[0])

        # find vertices
        _cls.__vertices = eval(','.join(bmd.split('vertices')[-1]
                                        .split(';')[0]
                                        .strip()[1:-1]
                                        .split()))

        # get blocks, order of vertices, nDivXYZ, grading
        blocks = bmd.split('blocks')[-1].split(';')[0].strip()
        xyz, simpleGrading = blocks.split('simpleGrading')

        _cls.__order, _cls.nDivXYZ = eval(','.join(xyz.split('hex')[-1].split()))

        simpleGrading = eval(','.join(simpleGrading.strip()[:-1]
                                      .replace('( ', '(')
                                      .replace(' )', ')')
                                      .split()))

        _cls.grading = SimpleGrading(
            *(MultiGrading(tuple(Grading(*i) for i in g))
              if isinstance(g, tuple) else Grading(g)
              for g in simpleGrading))

        # recreate boundary faces
        boundaryString = bmd.replace(' (', '(').replace(' )', ')') \
            .split('boundary(')[-1].strip().replace('});', '}') \
            .replace('));', ');').replace('((', ' (').replace(')(', ') (')

        _cls.values['boundary'] = {}
        for key, values in CppDictParser(boundaryString).values.iteritems():
            if isinstance(values, dict) and 'type' in values and 'faces' in values:
                values['faces'] = eval(str(values['faces']).replace(' ', ','))

                _cls.values['boundary'][key] = values

        del((lines, bmd))
        return _cls

    @classmethod
    def fromOriginAndSize(cls, origin, width, length, height, convertToMeters=1,
                          nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            origin: Minimum point of bounding box as (x, y, z).
            width: Width in x direction.
            length: Length in y direction.
            height: Height in y direction.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        vertices = tuple(
            vectormath.move(origin,
                            vectormath.sums((vectormath.scale(_xAxis, i *  width),
                                            vectormath.scale(_yAxis, j *  length),
                                            vectormath.scale(_zAxis, k *  height))
                            ))
            for i in range(2) for j in range(2) for k in range(2))

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromMinMax(cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None,
                   xAxis=None):
        """Create BlockMeshDict from minimum and maximum point.

        Args:
            minPt: Minimum point of bounding box as (x, y, z).
            maxPt: Maximum point of bounding box as (x, y, z).
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        diagonal2D = tuple(i - j for i, j in zip(maxPt, minPt))[:2]
        _angle = radians(vectormath.angleAnitclockwise(_xAxis[:2], diagonal2D))
        width = cos(_angle) * vectormath.length(diagonal2D)
        length = sin(_angle) * vectormath.length(diagonal2D)
        height = maxPt[2] - minPt[2]

        vertices = tuple(
            vectormath.move(minPt,
                            vectormath.sums((vectormath.scale(_xAxis, i *  width),
                                            vectormath.scale(_yAxis, j *  length),
                                            vectormath.scale(_zAxis, k *  height))
                            ))
            for i in range(2) for j in range(2) for k in range(2))

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromVertices(cls, vertices, convertToMeters=1, nDivXYZ=None,
                     grading=None, xAxis=None):
        """Create BlockMeshDict from vertices.

        Args:
            vertices: 8 vertices to define the bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__rawvertices = vertices

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
        _cls.__vertices = _cls.__sortVertices()

        # update self.values['boundary']
        _cls.__updateBoundaryFromSortedVertices()

        _cls.__order = tuple(range(8))

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading

        return _cls

    @classmethod
    def fromBFBlockGeometries(cls, BFBlockGeometries, convertToMeters=1,
                              nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            BFBlockGeometries: A collection of boundary surfaces for bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__BFBlockGeometries = BFBlockGeometries

        try:
            # collect uniqe vertices from all BFGeometries
            _cls.__rawvertices = tuple(
                set(v for f in _cls.__BFBlockGeometries
                    for vgroup in f.borderVertices
                    for v in vgroup))
        except AttributeError as e:
            raise TypeError('At least one of the input geometries is not a '
                            'Butterfly block geometry:\n\t{}'.format(e))

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
        _cls.__vertices = _cls.__sortVertices()

        # update self.values['boundary']
        _cls.__updateBoundaryFromBFBlockGeometries()

        _cls.__order = tuple(range(8))

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading

        return _cls

    @property
    def convertToMeters(self):
        """Get convertToMeters."""
        return self.values['convertToMeters']

    @property
    def boundary(self):
        """Get boundaries and a dictionary."""
        return self.values['boundary']

    @property
    def vertices(self):
        """Get the sorted list of vertices."""
        return self.__vertices

    @property
    def verticesOrder(self):
        """Get order of vertices in blocks."""
        return self.__order

    @property
    def geometry(self):
        """A tuple of BFGeometries for BoundingBox faces."""
        def __getBFGeometry(name, attr):
            bc = BoundingBoxBoundaryCondition()
            ind = attr['faces'] if hasattr(attr['faces'][0], '__iter__') else \
                (attr['faces'],)

            # unique indecies
            uniuqe = tuple(set(i for inx in ind for i in inx))

            renumberedIndx = tuple(tuple(uniuqe.index(i) for i in inx)
                                   for inx in ind)

            return BFGeometry(name, tuple(self.vertices[i] for i in uniuqe),
                              renumberedIndx, boundaryCondition=bc)

        if not self.__BFBlockGeometries:
            self.__BFBlockGeometries = tuple(
                __getBFGeometry(name, attr)
                for name, attr in self.boundary.iteritems())

        return self.__BFBlockGeometries

    @property
    def width(self):
        """Length of block in X direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[1]])

    @property
    def length(self):
        """Length of block in Y direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[3]])

    @property
    def height(self):
        """Length of block in Z direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[4]])

    @property
    def center(self):
        """Get center of the block."""
        return self.__averageVerices()

    @property
    def minZ(self):
        """Return minimum Z value of vertices in this block."""
        return self.vertices[self.verticesOrder[0]][2]

    @property
    def nDivXYZ(self):
        """Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5)."""
        return self.__nDivXYZ

    @nDivXYZ.setter
    def nDivXYZ(self, dXYZ):
        self.__nDivXYZ = tuple(int(v) for v in dXYZ) if dXYZ else (5, 5, 5)

    @property
    def grading(self):
        """A simpleGrading (default: simpleGrading(1, 1, 1))."""
        return self.__grading

    @grading.setter
    def grading(self, g):
        self.__grading = g if g else SimpleGrading()

        assert hasattr(self.grading, 'isSimpleGrading'), \
            'grading input ({}) is not a valid simpleGrading.'.format(g)

    def make2d(self, planeOrigin, planeNormal, width=0.1):
        """Create a new 2D blockMeshDict from this blockMeshDict.

        Args:
            planeOrigin: Plane origin as (x, y, z).
            planeNormal: Plane normal as (x, y, z).
            width: width of 2d blockMeshDict (default: 01).
        """
        # duplicate blockMeshDict
        bmd = self.duplicate()
        n = vectormath.normalize(planeNormal)

        # project all vertices to plane and move them in direction of normal
        # by half of width
        bmd.__vertices = tuple(
            self.__calculate2dPoints(v, planeOrigin, n, width)
            for v in bmd.vertices)

        # set boundary condition to empty
        # and number of divisions to 1 in shortest side
        minimum = min(bmd.width, bmd.length, bmd.height)
        if bmd.width == minimum:
            bmd.nDivXYZ = (1, bmd.nDivXYZ[1], bmd.nDivXYZ[2])
            # set both sides to empty

        elif bmd.length == minimum:
            bmd.nDivXYZ = (bmd.nDivXYZ[0], 1, bmd.nDivXYZ[2])
            # set inlet and outlet to empty
            # bmd.inlet.boundaryCondition = Empty()

        elif bmd.height == minimum:
            bmd.nDivXYZ = (bmd.nDivXYZ[0], bmd.nDivXYZ[1], 1)
            # set top and bottom to empty

        print('WARNING: make2d doesn\'t update boundary conditions to Empty.')
        return bmd

    @staticmethod
    def __calculate2dPoints(v, o, n, w):
        # project point
        p = vectormath.project(v, o, n)
        # move the projected point backwards for half of the width
        t = vectormath.scale(vectormath.normalize(vectormath.subtract(v, p)),
                             w / 2.0)
        return vectormath.move(p, t)

    def nDivXYZByCellSize(self, cellSizeXYZ):
        """Set number of divisions by cell size."""
        x, y, z = cellSizeXYZ
        self.nDivXYZ = int(round(self.width / x)), int(round(self.length / y)), \
            int(round(self.height / z))

    def updateMeshingParameters(self, meshingParameters):
        """Update meshing parameters for blockMeshDict."""
        if not meshingParameters:
            return

        assert hasattr(meshingParameters, 'isMeshingParameters'), \
            'Expected MeshingParameters not {}'.format(type(meshingParameters))

        if meshingParameters.cellSizeXYZ:
            self.nDivXYZByCellSize(meshingParameters.cellSizeXYZ)

        if meshingParameters.grading:
            self.grading = meshingParameters.grading

    def __updateBoundaryFromSortedVertices(self):
        """Update boundary dictionary based on BFBlockGeometries input."""
        self.values['boundary']['boundingbox'] = {
            'type': 'wall',
            'faces': ((0, 3, 2, 1), (4, 5, 6, 7),
                      (0, 1, 5, 4), (1, 2, 6, 5),
                      (2, 3, 7, 6), (3, 0, 4, 7),
                      )
        }

    def __updateBoundaryFromBFBlockGeometries(self):
        """Update boundary dictionary based on BFBlockGeometries input."""
        for geo in self.__BFBlockGeometries:
            try:
                self.values['boundary'][geo.name] = {
                    'type': geo.boundaryCondition.type,
                    'faces': tuple(tuple(self.vertices.index(v) for v in verGroup)
                                   for verGroup in geo.borderVertices)
                }
            except AttributeError as e:
                raise TypeError('Wrong input geometry!\n{}'.format(e))

    def __boundaryToOpenFOAM(self):
        _body = "   %s\n" \
                "   {\n" \
                "       type %s;\n" \
                "       faces\n" \
                "       (" \
                "       %s\n" \
                "       );\n" \
                "   }\n"

        col = (_body % (name, attr['type'],
               '\n' + '\n'.join('\t' + str(indices).replace(",", "")
                                for indices in attr['faces']))
               if isinstance(attr['faces'][0], tuple) else
               _body % (name, attr['type'],
                        '\n\t' + str(attr['faces']).replace(",", ""))
               for name, attr in self.boundary.iteritems())

        return 'boundary\n(%s);\n' % '\n'.join(col)

    @staticmethod
    def __distance(v1, v2):
        return sqrt(sum((x - y) ** 2 for x, y in zip(v1, v2)))

    def __averageVerices(self):
        _x, _y, _z = 0, 0, 0

        for ver in self.__rawvertices:
            _x += ver[0]
            _y += ver[1]
            _z += ver[2]

        return _x * self.convertToMeters / len(self.__rawvertices), \
            _y * self.convertToMeters / len(self.__rawvertices), \
            _z * self.convertToMeters / len(self.__rawvertices)

    def __sortVertices(self):
        """sort input vertices."""
        groups = {}
        for p in self.__rawvertices:
            if p[2] not in groups:
                groups[p[2]] = []

            groups[p[2]].append((p[0], p[1]))

        zValues = groups.keys()
        zValues.sort()
        pointGroups = groups.values()

        assert len(zValues) == 2, \
            'Number of Z values must be 2 not {}: {}.'.format(len(zValues),
                                                              zValues)

        for g in pointGroups:
            assert len(g) == 4

        # the points in both height are identical so I just take the first group
        # and sort them
        xAxisReversed = (-self.xAxis[0], -self.xAxis[1])
        centerPt = self.center[:2]
        sortedPoints2d = \
            sorted(pointGroups[0],
                   key=lambda x: vectormath.angleAnitclockwise(
                       xAxisReversed, tuple(c1 - c2 for c1, c2
                                            in zip(x, centerPt))))

        sortedPoints = tuple((pt[0], pt[1], z) for z in zValues
                             for pt in sortedPoints2d)
        return sortedPoints

    def toOpenFOAM(self):
        """Return OpenFOAM representation as a string."""
        _hea = self.header()
        _body = "\nconvertToMeters %.4f;\n" \
                "\n" \
                "vertices\n" \
                "(\n\t%s\n);\n" \
                "\n" \
                "blocks\n" \
                "(\nhex %s %s %s\n);\n" \
                "\n" \
                "edges\n" \
                "(%s);\n" \
                "\n" \
                "%s" \
                "\n" \
                "mergePatchPair\n" \
                "(%s);\n"

        return _hea + \
            _body % (
                self.convertToMeters,
                "\n\t".join(tuple(str(ver).replace(",", "")
                                  for ver in self.vertices)),
                str(self.verticesOrder).replace(",", ""),
                str(self.nDivXYZ).replace(",", ""),
                self.grading,  # blocks
                "\n",  # edges
                self.__boundaryToOpenFOAM(),  # boundary
                "\n")  # merge patch pair

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """BlockMeshDict representation."""
        return self.toOpenFOAM()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#butterfly.blockMeshDict.BlockMeshDict">BlockMeshDict</a></li>
          <li>butterfly.foamfile.FoamFile</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.convertBoolValue">
    <p>def <span class="ident">convertBoolValue</span>(</p><p>v=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert Boolean values to on/off string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.convertBoolValue', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.convertBoolValue" class="source">
    <pre><code>@staticmethod
def convertBoolValue(v=True):
    """Convert Boolean values to on/off string."""
    _v = ('off', 'on')
    if v in _v:
        return v
    if v:
        return 'on'
    else:
        return 'off'
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.boundary" class="name">var <span class="ident">boundary</span></p>
            

            
  
    <div class="desc"><p>Get boundaries and a dictionary.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>Get center of the block.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.convertToMeters" class="name">var <span class="ident">convertToMeters</span></p>
            

            
  
    <div class="desc"><p>Get convertToMeters.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.geometry" class="name">var <span class="ident">geometry</span></p>
            

            
  
    <div class="desc"><p>A tuple of BFGeometries for BoundingBox faces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.grading" class="name">var <span class="ident">grading</span></p>
            

            
  
    <div class="desc"><p>A simpleGrading (default: simpleGrading(1, 1, 1)).</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>Length of block in Z direction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isConstantFile" class="name">var <span class="ident">isConstantFile</span></p>
            

            
  
    <div class="desc"><p>Check if the file location is 'constant' folder.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isFoamFile" class="name">var <span class="ident">isFoamFile</span></p>
            

            
  
    <div class="desc"><p>Return True for FoamFile.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isSystemFile" class="name">var <span class="ident">isSystemFile</span></p>
            

            
  
    <div class="desc"><p>Check if the file location is 'system' folder.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isZeroFile" class="name">var <span class="ident">isZeroFile</span></p>
            

            
  
    <div class="desc"><p>Check if the file location is folder 0.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.length" class="name">var <span class="ident">length</span></p>
            

            
  
    <div class="desc"><p>Length of block in Y direction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.minZ" class="name">var <span class="ident">minZ</span></p>
            

            
  
    <div class="desc"><p>Return minimum Z value of vertices in this block.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.nDivXYZ" class="name">var <span class="ident">nDivXYZ</span></p>
            

            
  
    <div class="desc"><p>Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.parameters" class="name">var <span class="ident">parameters</span></p>
            

            
  
    <div class="desc"><p>Get list of parameters.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.values" class="name">var <span class="ident">values</span></p>
            

            
  
    <div class="desc"><p>Return values as a dictionary.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.vertices" class="name">var <span class="ident">vertices</span></p>
            

            
  
    <div class="desc"><p>Get the sorted list of vertices.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.verticesOrder" class="name">var <span class="ident">verticesOrder</span></p>
            

            
  
    <div class="desc"><p>Get order of vertices in blocks.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>Length of block in X direction.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, values=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Init class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.__init__', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.__init__" class="source">
    <pre><code>def __init__(self, values=None):
    """Init class."""
    FoamFile.__init__(self, name='blockMeshDict', cls='dictionary',
                      location='system', defaultValues=self.__defaultValues,
                      values=values)
    self.__BFBlockGeometries = None # this will be overwritten in classmethods
    self.__vertices = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.ToString">
    <p>def <span class="ident">ToString</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrite .NET ToString method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.ToString', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.ToString" class="source">
    <pre><code>def ToString(self):
    """Overwrite .NET ToString method."""
    return self.__repr__()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.body">
    <p>def <span class="ident">body</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return body string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.body', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.body" class="source">
    <pre><code>def body(self):
    """Return body string."""
    # remove None values
    def removeNone(d):
        if isinstance(d, (dict, OrderedDict)):
            return OrderedDict((k, removeNone(v))
                               for k, v in d.iteritems()
                               if v and removeNone(v))
        elif isinstance(d, (list, tuple)):
            return [removeNone(v) for v in d if v and removeNone(v)]
        else:
            return d
        return removeNone
    _values = removeNone(self.values)
    # add an empty dict for refinementRegions
    if 'castellatedMeshControls' in _values:
        if 'refinementRegions' not in _values['castellatedMeshControls']:
            _values['castellatedMeshControls']['refinementRegions'] = {}
    # make python dictionary look like c++ dictionary!!
    of = json.dumps(_values, indent=4, separators=(";", "\t\t")) \
        .replace('\\"', '@').replace('"\n', ";\n").replace('"', '') \
        .replace('};', '}').replace('\t\t{', '{').replace('@', '"')
    # remove first and last {} and prettify[!] the file
    l = (line[4:] if not line.endswith('{') else self._splitLine(line)
         for line in of.split("\n")[1:-1])
    return "\n\n".join(l)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.duplicate">
    <p>def <span class="ident">duplicate</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a copy of this object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.duplicate', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.duplicate" class="source">
    <pre><code>def duplicate(self):
    """Return a copy of this object."""
    return deepcopy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries">
    <p>def <span class="ident">fromBFBlockGeometries</span>(</p><p>cls, BFBlockGeometries, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from BFBlockGeometries.</p>
<p>Args:
    BFBlockGeometries: A collection of boundary surfaces for bounding box.
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries" class="source">
    <pre><code>@classmethod
def fromBFBlockGeometries(cls, BFBlockGeometries, convertToMeters=1,
                          nDivXYZ=None, grading=None, xAxis=None):
    """Create BlockMeshDict from BFBlockGeometries.
    Args:
        BFBlockGeometries: A collection of boundary surfaces for bounding box.
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _cls = cls()
    _cls.values['convertToMeters'] = convertToMeters
    _cls.__BFBlockGeometries = BFBlockGeometries
    try:
        # collect uniqe vertices from all BFGeometries
        _cls.__rawvertices = tuple(
            set(v for f in _cls.__BFBlockGeometries
                for vgroup in f.borderVertices
                for v in vgroup))
    except AttributeError as e:
        raise TypeError('At least one of the input geometries is not a '
                        'Butterfly block geometry:\n\t{}'.format(e))
    # sort vertices
    _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
    _cls.__vertices = _cls.__sortVertices()
    # update self.values['boundary']
    _cls.__updateBoundaryFromBFBlockGeometries()
    _cls.__order = tuple(range(8))
    _cls.nDivXYZ = nDivXYZ
    # assign grading
    _cls.grading = grading
    return _cls
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromFile">
    <p>def <span class="ident">fromFile</span>(</p><p>cls, filepah)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a blockMeshDict from file.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromFile', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromFile" class="source">
    <pre><code>@classmethod
def fromFile(cls, filepah):
    """Create a blockMeshDict from file."""
    _cls = cls()
    with open(filepah, 'rb') as bf:
        lines = CppDictParser._removeComments(bf.read())
        bmd = ' '.join(lines.replace('\r\n', ' ').replace('\n', ' ').split())
    _cls.values['convertToMeters'] = \
        float(bmd.split('convertToMeters')[-1].split(';')[0])
    # find vertices
    _cls.__vertices = eval(','.join(bmd.split('vertices')[-1]
                                    .split(';')[0]
                                    .strip()[1:-1]
                                    .split()))
    # get blocks, order of vertices, nDivXYZ, grading
    blocks = bmd.split('blocks')[-1].split(';')[0].strip()
    xyz, simpleGrading = blocks.split('simpleGrading')
    _cls.__order, _cls.nDivXYZ = eval(','.join(xyz.split('hex')[-1].split()))
    simpleGrading = eval(','.join(simpleGrading.strip()[:-1]
                                  .replace('( ', '(')
                                  .replace(' )', ')')
                                  .split()))
    _cls.grading = SimpleGrading(
        *(MultiGrading(tuple(Grading(*i) for i in g))
          if isinstance(g, tuple) else Grading(g)
          for g in simpleGrading))
    # recreate boundary faces
    boundaryString = bmd.replace(' (', '(').replace(' )', ')') \
        .split('boundary(')[-1].strip().replace('});', '}') \
        .replace('));', ');').replace('((', ' (').replace(')(', ') (')
    _cls.values['boundary'] = {}
    for key, values in CppDictParser(boundaryString).values.iteritems():
        if isinstance(values, dict) and 'type' in values and 'faces' in values:
            values['faces'] = eval(str(values['faces']).replace(' ', ','))
            _cls.values['boundary'][key] = values
    del((lines, bmd))
    return _cls
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromMinMax">
    <p>def <span class="ident">fromMinMax</span>(</p><p>cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from minimum and maximum point.</p>
<p>Args:
    minPt: Minimum point of bounding box as (x, y, z).
    maxPt: Maximum point of bounding box as (x, y, z).
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromMinMax', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromMinMax" class="source">
    <pre><code>@classmethod
def fromMinMax(cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None,
               xAxis=None):
    """Create BlockMeshDict from minimum and maximum point.
    Args:
        minPt: Minimum point of bounding box as (x, y, z).
        maxPt: Maximum point of bounding box as (x, y, z).
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
    _zAxis = (0, 0, 1)
    _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
    diagonal2D = tuple(i - j for i, j in zip(maxPt, minPt))[:2]
    _angle = radians(vectormath.angleAnitclockwise(_xAxis[:2], diagonal2D))
    width = cos(_angle) * vectormath.length(diagonal2D)
    length = sin(_angle) * vectormath.length(diagonal2D)
    height = maxPt[2] - minPt[2]
    vertices = tuple(
        vectormath.move(minPt,
                        vectormath.sums((vectormath.scale(_xAxis, i *  width),
                                        vectormath.scale(_yAxis, j *  length),
                                        vectormath.scale(_zAxis, k *  height))
                        ))
        for i in range(2) for j in range(2) for k in range(2))
    return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                            xAxis)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize">
    <p>def <span class="ident">fromOriginAndSize</span>(</p><p>cls, origin, width, length, height, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from BFBlockGeometries.</p>
<p>Args:
    origin: Minimum point of bounding box as (x, y, z).
    width: Width in x direction.
    length: Length in y direction.
    height: Height in y direction.
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize" class="source">
    <pre><code>@classmethod
def fromOriginAndSize(cls, origin, width, length, height, convertToMeters=1,
                      nDivXYZ=None, grading=None, xAxis=None):
    """Create BlockMeshDict from BFBlockGeometries.
    Args:
        origin: Minimum point of bounding box as (x, y, z).
        width: Width in x direction.
        length: Length in y direction.
        height: Height in y direction.
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
    _zAxis = (0, 0, 1)
    _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
    vertices = tuple(
        vectormath.move(origin,
                        vectormath.sums((vectormath.scale(_xAxis, i *  width),
                                        vectormath.scale(_yAxis, j *  length),
                                        vectormath.scale(_zAxis, k *  height))
                        ))
        for i in range(2) for j in range(2) for k in range(2))
    return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                            xAxis)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromVertices">
    <p>def <span class="ident">fromVertices</span>(</p><p>cls, vertices, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from vertices.</p>
<p>Args:
    vertices: 8 vertices to define the bounding box.
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromVertices', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromVertices" class="source">
    <pre><code>@classmethod
def fromVertices(cls, vertices, convertToMeters=1, nDivXYZ=None,
                 grading=None, xAxis=None):
    """Create BlockMeshDict from vertices.
    Args:
        vertices: 8 vertices to define the bounding box.
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _cls = cls()
    _cls.values['convertToMeters'] = convertToMeters
    _cls.__rawvertices = vertices
    # sort vertices
    _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
    _cls.__vertices = _cls.__sortVertices()
    # update self.values['boundary']
    _cls.__updateBoundaryFromSortedVertices()
    _cls.__order = tuple(range(8))
    _cls.nDivXYZ = nDivXYZ
    # assign grading
    _cls.grading = grading
    return _cls
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.getValueByParameter">
    <p>def <span class="ident">getValueByParameter</span>(</p><p>self, parameter)</p>
    </div>
    

    
  
    <div class="desc"><p>Get values for a given parameter by parameter name.</p>
<p>Args:
    parameter: Name of a parameter as a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.getValueByParameter', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.getValueByParameter" class="source">
    <pre><code>def getValueByParameter(self, parameter):
    """Get values for a given parameter by parameter name.
    Args:
        parameter: Name of a parameter as a string.
    """
    try:
        return self.values[parameter]
    except KeyError:
        raise KeyError('{} is not available in {}.'.format(
            parameter, self.__class__.__name__
        ))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.header">
    <p>def <span class="ident">header</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return open foam style string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.header', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.header" class="source">
    <pre><code>def header(self):
    """Return open foam style string."""
    if self.location:
        return Header.header() + \
            "FoamFile\n{\n" \
            "\tversion\t\t%s;\n" \
            "\tformat\t\t%s;\n" \
            "\tclass\t\t%s;\n" \
            "\tlocation\t%s;\n" \
            "\tobject\t\t%s;\n" \
            "}\n" % (self.__version, self.format, self.cls, self.location,
                     self.name)
    else:
        return Header.header() + \
            "FoamFile\n{\n" \
            "\tversion\t\t%s;\n" \
            "\tformat\t\t%s;\n" \
            "\tclass\t\t%s;\n" \
            "\tobject\t\t%s;\n" \
            "}\n" % (self.__version, self.format, self.cls, self.name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.make2d">
    <p>def <span class="ident">make2d</span>(</p><p>self, planeOrigin, planeNormal, width=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a new 2D blockMeshDict from this blockMeshDict.</p>
<p>Args:
    planeOrigin: Plane origin as (x, y, z).
    planeNormal: Plane normal as (x, y, z).
    width: width of 2d blockMeshDict (default: 01).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.make2d', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.make2d" class="source">
    <pre><code>def make2d(self, planeOrigin, planeNormal, width=0.1):
    """Create a new 2D blockMeshDict from this blockMeshDict.
    Args:
        planeOrigin: Plane origin as (x, y, z).
        planeNormal: Plane normal as (x, y, z).
        width: width of 2d blockMeshDict (default: 01).
    """
    # duplicate blockMeshDict
    bmd = self.duplicate()
    n = vectormath.normalize(planeNormal)
    # project all vertices to plane and move them in direction of normal
    # by half of width
    bmd.__vertices = tuple(
        self.__calculate2dPoints(v, planeOrigin, n, width)
        for v in bmd.vertices)
    # set boundary condition to empty
    # and number of divisions to 1 in shortest side
    minimum = min(bmd.width, bmd.length, bmd.height)
    if bmd.width == minimum:
        bmd.nDivXYZ = (1, bmd.nDivXYZ[1], bmd.nDivXYZ[2])
        # set both sides to empty
    elif bmd.length == minimum:
        bmd.nDivXYZ = (bmd.nDivXYZ[0], 1, bmd.nDivXYZ[2])
        # set inlet and outlet to empty
        # bmd.inlet.boundaryCondition = Empty()
    elif bmd.height == minimum:
        bmd.nDivXYZ = (bmd.nDivXYZ[0], bmd.nDivXYZ[1], 1)
        # set top and bottom to empty
    print('WARNING: make2d doesn\'t update boundary conditions to Empty.')
    return bmd
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize">
    <p>def <span class="ident">nDivXYZByCellSize</span>(</p><p>self, cellSizeXYZ)</p>
    </div>
    

    
  
    <div class="desc"><p>Set number of divisions by cell size.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize" class="source">
    <pre><code>def nDivXYZByCellSize(self, cellSizeXYZ):
    """Set number of divisions by cell size."""
    x, y, z = cellSizeXYZ
    self.nDivXYZ = int(round(self.width / x)), int(round(self.length / y)), \
        int(round(self.height / z))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.save">
    <p>def <span class="ident">save</span>(</p><p>self, projectFolder, subFolder=None, overwrite=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Save to file.</p>
<p>Args:
    projectFolder: Path to project folder as a string.
    subFolder: Optional input for subFolder (default: self.location).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.save', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.save" class="source">
    <pre><code>def save(self, projectFolder, subFolder=None, overwrite=True):
    """Save to file.
    Args:
        projectFolder: Path to project folder as a string.
        subFolder: Optional input for subFolder (default: self.location).
    """
    subFolder = subFolder or self.location.replace('"', '')
    fp = os.path.join(projectFolder, subFolder, self.name)
    if not overwrite and os.path.isfile(fp):
        return
    with open(fp, "wb") as outf:
        outf.write(self.toOpenFOAM())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.setValueByParameter">
    <p>def <span class="ident">setValueByParameter</span>(</p><p>self, parameter, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Set value for a parameter.</p>
<p>Args:
    parameter: Name of a parameter as a string.
    value: Parameter value as a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.setValueByParameter', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.setValueByParameter" class="source">
    <pre><code>def setValueByParameter(self, parameter, value):
    """Set value for a parameter.
    Args:
        parameter: Name of a parameter as a string.
        value: Parameter value as a string.
    """
    self.values[parameter] = value
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM">
    <p>def <span class="ident">toOpenFOAM</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return OpenFOAM representation as a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM" class="source">
    <pre><code>def toOpenFOAM(self):
    """Return OpenFOAM representation as a string."""
    _hea = self.header()
    _body = "\nconvertToMeters %.4f;\n" \
            "\n" \
            "vertices\n" \
            "(\n\t%s\n);\n" \
            "\n" \
            "blocks\n" \
            "(\nhex %s %s %s\n);\n" \
            "\n" \
            "edges\n" \
            "(%s);\n" \
            "\n" \
            "%s" \
            "\n" \
            "mergePatchPair\n" \
            "(%s);\n"
    return _hea + \
        _body % (
            self.convertToMeters,
            "\n\t".join(tuple(str(ver).replace(",", "")
                              for ver in self.vertices)),
            str(self.verticesOrder).replace(",", ""),
            str(self.nDivXYZ).replace(",", ""),
            self.grading,  # blocks
            "\n",  # edges
            self.__boundaryToOpenFOAM(),  # boundary
            "\n")  # merge patch pair
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters">
    <p>def <span class="ident">updateMeshingParameters</span>(</p><p>self, meshingParameters)</p>
    </div>
    

    
  
    <div class="desc"><p>Update meshing parameters for blockMeshDict.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters" class="source">
    <pre><code>def updateMeshingParameters(self, meshingParameters):
    """Update meshing parameters for blockMeshDict."""
    if not meshingParameters:
        return
    assert hasattr(meshingParameters, 'isMeshingParameters'), \
        'Expected MeshingParameters not {}'.format(type(meshingParameters))
    if meshingParameters.cellSizeXYZ:
        self.nDivXYZByCellSize(meshingParameters.cellSizeXYZ)
    if meshingParameters.grading:
        self.grading = meshingParameters.grading
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.updateValues">
    <p>def <span class="ident">updateValues</span>(</p><p>self, v, replace=False, mute=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Update current values from dictionary v.</p>
<p>if key is not available in current values it will be added, if the key
already exists it will be updated.</p>
<p>Returns:
    True is the dictionary is updated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.updateValues', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.updateValues" class="source">
    <pre><code>def updateValues(self, v, replace=False, mute=False):
    """Update current values from dictionary v.
    if key is not available in current values it will be added, if the key
    already exists it will be updated.
    Returns:
        True is the dictionary is updated.
    """
    def logChanges(original, new):
        """compare this dictionary with the current values."""
        if original is None:
            original = {}
        for key, value in new.items():
            if key not in original:
                # there is a new key so dictionary has changed.
                if not mute:
                    print '{} :: New values are added for {}.' \
                        .format('.'.join(self.__parents), key)
                self.__hasChanged = True
                return
            if isinstance(value, (dict, OrderedDict)):
                self.__parents.append(key)
                logChanges(original[key], value)
            elif str(original[key]) != str(value):
                    # there is a change in value
                    if not mute:
                        print '{}.{} is changed from "{}" to "{}".'\
                            .format('.'.join(self.__parents), key,
                                    original[key] if len(str(original[key])) < 100
                                    else '%s...' % str(original[key])[:100],
                                    value if len(str(value)) < 100
                                    else '%s...' % str(value)[:100])
                    self.__hasChanged = True
                    return
    def modifyDict(original, new):
        """Modify a dictionary based on a new dictionary."""
        for key, value in new.items():
            if key in original and isinstance(value, dict):
                if isinstance(original[key], dict):
                    modifyDict(original[key], value)
                else:
                    # the value was not a dict, replce them with the new one
                    original[key] = value
            else:
                original[key] = value
        return original
    assert isinstance(v, dict), 'Expected dictionary not {}!'.format(type(v))
    self.__parents = [self.__class__.__name__]
    self.__hasChanged = False
    logChanges(self.__values, v)
    if self.__hasChanged:
        if replace:
            self.__values.update(v)
        else:
            self.__values = modifyDict(self.__values, v)
        return True
    else:
        return False
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a>
    </p>
  </footer>
</div>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
